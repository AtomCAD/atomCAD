/*
 * This shader matrix patches from one buffer to another.
 
 */
#version 450

// If there are ever enough objects in motion
// that this is a bottleneck, benchmark different
// thread group sizes.
layout(local_size_x = 64, local_size_y = 1,local_size_z = 1) in;

layout(set = 0, binding = 0) uniform Uniforms {
    uint total_patches;
};

// Try to make these two parts of a single buffer.
layout(set = 1, binding = 0, std430) readonly buffer SrcIndices {
    uint patch_to_transform[];
};
layout(set = 1, binding = 1, std430) readonly buffer Src {
    mat4 patches[];
};

layout(set = 2, binding = 0) buffer Dst {
    mat4 transforms[];
};

void main(void) {
    const uint patch_index = gl_GlobalInvocationID.x;

    if (patch_index >= total_patches) {
        // drop the invocations that get added to the top
        // because of 64 threads per invocations.
        return;
    }

    // not a fan of all the indirection here, but
    // struct Patch {
    //     uint transform_idx;
    //     mat3 patch;
    // }
    // isn't aligned to 4 bytes :/, even with std430.
    // See https://discord.com/channels/318590007881236480/318783283984990210/760326952685928448
    transforms[patch_to_transform[patch_index]] = patches[patch_index];
}